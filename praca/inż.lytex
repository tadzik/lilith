\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{pgfplots}
\usepackage{color}
\usepackage{graphicx}
\pgfplotsset{compat=newest}
\title{Generowanie arkuszy muzycznych na podstawie sygnału MIDI z instrumentów klawiszowych}
\author{Tadeusz Sośnierz}
\date{}
\begin{document}

\maketitle

\newpage
\tableofcontents

\newpage
\section{Abstrakt}

Niniejsza praca opisuje cele, założenia i implementację programu dokonującego automatycznej
konwersji nagrań muzycznych w formacie MIDI do arkuszy nutowych w formatach PNG lub PDF.
Założenia i cel projektu są opisane w rozdziale~\ref{sec:wstep}. Opisuje on dla kogo jest
tworzony program, jaki jest oczekiwany rezultat jak również porównuje projekt z innymi
dostępnymi na rynku rozwiązaniami tego typu.

Rozdział \ref{sec:o_nutach} zawiera krótkie wprowadzenie do teorii muzyki oraz zapisu nutowego,
znajomość której jest konieczna w celu zaznajomienia się z terminologią i problematyką
dalszych rozdziałów pracy.

W rozdziale \ref{sec:architektura} znajduje się szczegółowy opis komponentów na jakie
podzielony jest projekt Lilith. Opisane są zależności oraz szczegóły techniczne implementacji
poszczególnych części projektu.

Rozdział \ref{sec:opis_algorytmu} zawiera szczegółowy opis metod statystycznych
i~heurystycznych oraz dokładny opis algorytmów którymi posługuje się program w celu
wygenerowania dobrej jakości zapisu nutowego. Wyjaśnia również, na podstawie jakich kryteriów
decydujemy jaki zapis jest akceptowalny.

Opis interfejsu programu, będący swego rodzaju dokumentacją dla użytkownika znajduje się
w~rozdziale~\ref{sec:opis_interfejsu}. Opisane jest w nim dokładnie jak posługiwać się
programem, zawiera również przykłady użycia dla kilku utworów oraz pokazuje sposób radzenia
sobie z ewentualnymi niedoskonałościami wygenerowanego arkusza.

W rozdziale \ref{sec:podsumowanie} znajduje się podsumowanie projektu, wnioski oraz
ocena spełnienia wymagań postawionych przed projektem.

Wreszcie rozdział \ref{sec:bibliografia} jest bibliografią pracy, zawierającą odnośniki
do prac, książek i materiałów które pomogły w realizacji projektu i opisaniu go w niniejszej
pracy.

\newpage
\section{Wstęp}
\label{sec:wstep}

\subsection{Cel pracy}

Praca ma na celu stworzenie programu generującego zapis nutowy z nagrania utworu wykonanego
na instrumencie klawiszowym.

\subsection{Grupa odbiorcza i zastosowania}

Program ma służyć przede wszystkim muzykom, artystom chcącym uniknąć żmudnego zapisywania
nut czy to na papierze czy na klawiaturze komputera. Przerywanie wykonania co kilka chwil
jest niewygodne, rozpraszające i czasochłonne. Wielu artystów publikujących swoje nagrania
w internecie bardzo często nie dołącza do nich arkuszy muzycznych właśnie ze względu na
pracochłonność takiego procesu, czasem wyceniając ich przygotowanie na kilkadziesiąt
euro\footnote{\url{http://vkgoeswild.com/?section=sheets}} (niemal połowa ceny zaaranżowania
dowolnego utworu).

Klawiatura instrumentu, będąc również narzędziem do wykonania utworu jest najbardziej
naturalnym dla artysty urządzeniem mogącym ułatwić im przygotowanie arkusza. Praca ma zatem na
celu dostarczenie programu, który przejmie na siebie obowiązek wykonania za człowieka jak
największej części pracy (docelowo całości), jaką trzeba włożyć w przygotowanie arkusza
muzycznego.

\subsection{Trudności i ograniczenia}

Rzeczą nie do końca oczywistą a bardzo istotną jest fakt, że zadaniem programu nie jest
zreprodukowanie muzyki w innym nieco formacie -- zadaniem programu jest zobrazowanie
działań wykonawcy utworu w taki sposób, aby innym muzykom było łatwo go odtworzyć.
Każdy utwór muzyczny można zapisać na arkuszu nutowym na nieskończoną ilość sposobów;
zadaniem programu jest wybranie heurystycznie takiego, który będzie jak najbardziej
przejrzysty dla człowieka. Bardziej niz mechaniczna precyzja istotne będzie branie poprawki
na niedokładność ludzkiego wykonania, ale również wnioskowanie rzeczy nie będących w żaden
sposób zapisanych w nagraniu dźwiękowym: na przykład, którą ręką był prawdopodobnie grany
zadany klawisz?

Efektem heurystycznego interpretowania zamiarów użytkownika jest również fakt, iż nie zawsze
będziemy w stanie trafnie odgadnąć jego zamiary; mimo najlepszych starań i algorytmów oceny,
wynik nie zawsze będzie satysfakcjonujący. Drugim zadaniem programu jest zatem udostępnienie
wygodnej możliwości dopasowania dobranych przezeń parametrów w celu skorygowania błędnych
założeń programu, jak również danie użytkownikowi możliwości łatwego poprawienia popełnionych
przez niego błędów w samym wykonaniu utworu.

\subsection{Obecne rozwiązania}

Na rynku nie istnieją w zasadzie programy umożliwiające konwersję całych, gotowych utworów
na zapis nutowy. Istnieją profesjonalne edytory arkuszy muzycznych (takie jak
Finale\footnote{\url{http://www.finalemusic.com/}} czy
Sibelius\footnote{\url{http://www.avid.com/US/products/sibelius}}, które dają możliwość
nagrywania pojedyńczych dźwięków bądź krótkich monofonicznych melodii, trudno jednak mówić
o automatycznej konwersji kompletnych, złożonych utworów.
Cena 600 dolarów za licencję każdego z tych
programów umieszcza je również poza zasięgiem amatorów i pasjonatów muzyki pragnących
podzielić się ze światem swoją twórczością. Program napisany w ramach tej pracy jest, jak się
okazuje, jedynym które podejmuje problem konwersji kompletnych utworów na gotowe arkusze
muzyczne.

\subsection{Oczekiwane rezultaty}

Celem projektu jest zrzucenie możliwie jak największej ilości mozolnej, podatnej na błędy pracy
na barki komputera. Część rzeczy, takie jak wysokości poszczególnych dźwięków w utworze
program będzie w stanie wyznaczyć bezbłędnie. Inne, jak ich długość czy grupowanie w akordy
moze sprawić więcej kłopotów: niedokładność wykonania i kompensowanie błędów użytkownika
może doprowadzić do drobnych różnic między zamierzoną a wyznaczoną długością poszczególnych nut.
Wreszcie podział utworu na ręce jest zadaniem skomplikowanym i potencjalnie sprawiającym dużo
problemów w skrajnych przypadkach, mogącym doprowadzić do bardzo niespodziewanych wyników.
Wiele z tych trudności da się przezwyciężyć lub skorygować, jednak niemal nigdy nie uda się
perfekcyjnie wygenerować arkusza niewymagającego żadnych poprawek. Program musi zatem dostarczać
łatwą i wygodną możliwość skorygowania błędów wynikłych ze złej interpretacji utworu.

Projekt można uznać za udany i użyteczny, jeśli faktycznie łatwiej będzie tworzyć arkusze
muzyczne z jego pomocą niż pisać je ręcznie od zera. Im większą część pracy uda się przenieść
na program, tym większa jego użyteczność.

\newpage
\section{Wprowadzenie do zapisu nutowego}
\label{sec:o_nutach}

Poniższy rozdział ma na celu wyjaśnienie podstawowych pojęć muzycznych,
na których operować będzie dalsza część pracy. Wyjaśni też, jakie trudności
wynikają z niezdefiniowanych formalnie elementów tej dziedziny sztuki.

Zapis nutowy jest graficzną reprezentacją utworu muzycznego. 
Składa się on z \emph{pięciolinii} -- pięciu poziomych linii, oraz znaków na niej.
Utwory często składają się z kilku pięciolinii połączonych klamrą, co oznacza, że
grane są one równocześnie. W przypadku pianina używane są zazwyczaj dwie pięciolinie:
jedna dla lewej, a jedna dla prawej ręki.

Naistotniejszą rzeczą znajdującą się na pięciolinii są \emph{nuty}, opisujące długość
oraz wysokość dźwięków w utworze, jak również symbole takie jak pauzy (cisze w utworze),
oraz inne symbole takie jak oznaczenia tempa, tonacji czy głośności utworu.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    upper = {
        \key d \major
        \clef "treble"
    r2 a'8 b'8 cis''4 | e''4 e''4 d''8 cis''8 b'8. a'16 | b'8 cis''8 b'4 r8 a'8 b'8. a'16 | b'8 cis''8 fis'4 r8 a'8 b'8. a'16
      
    }
    lower = {
        \key d \major
        \clef "bass"
    r2 r4 a,8 e8 | a8 e8 b,8 fis8 b8 fis8 g,8 d8 | g8 d8 d,8 a,8 d8 a,8 b,8 fis8 | b8 fis8 fis,8 c8 fis8 c8 b,8 fis8
    }
    \score {
        \new PianoStaff <<
            \time 4/4
            \new Staff = "upper" \upper
            \new Staff = "lower" \lower
        >>
        \layout { }
    }
    \end{lilypond}
    \caption{Przykład zapisu nutowego}
    \label{fig:worms_theme}
\end{figure}


Każda nuta reprezentuje jeden dźwięk występujący w utworze -- jego długość oraz
wysokość. Długość dźwięku zależy od wyglądu samej nuty, wysokość zaś od pozycji (pionowej)
nuty na pięciolinii. Po pozycji poziomej nut widać, w jakiej kolejności są one grane, oraz
które z nich grane są równocześnie (również na przestrzeni kilku połączonych pięciolinii).

Nuty dzielimy pod kątem długości dźwięku na \emph{całe nuty}, \emph{półnuty},
\emph{ćwierćnuty}, \emph{ósemki}, \emph{szesnastki} i \emph{trzydziestodwójki}
gdzie półnuta ma długość połowy całej nuty, ćwierćnuta oznacza jedną
czwartą całej nuty itd. Faktyczna długość całej nuty (np. w milisekundach) nie jest
zazwyczaj precyzyjnie określona; O ile w niektórych arkuszach muzycznych można spotkać
adnotację, określającą ile
dokładnie uderzeń na minutę (BPM) przekłada się na jedną wybraną nutę.
W ostatnim przykładzie z rysunku~\ref{fig:presto} widzimy zapis sugerujący
długość ćwierćnuty równą pół sekundy (120 ćwierćnut na minutę).
Zazwyczaj jednak informację tę pomija się, pozostawiając ją do interpretacji wykonawcy utworu.
Przeważnie jedynym, co informuje muzyka o tempie grania utworu jest
umieszczenie na początku arkusza włoskiego słowa określającego zamierzoną
prędkość utworu (np. \emph{Largo} oznaczające wolno, \emph{Allegro} -- szybko, czy
\emph{Andante}, będące w przybliżeniu tempem osoby idącej pieszo).

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    \relative c'' {
        \time 3/4
        \tempo "Andante"
        a4 a a
    }
    \end{lilypond}
    \begin{lilypond}
    \relative c'' {
        \time 6/8
        \tempo 4. = 96
        a4. a
    }
    \end{lilypond}
    \begin{lilypond}
    \relative c'' {
        \time 4/4
        \tempo  "Presto" 4 = 120
        a4 a a a
    }
    \end{lilypond}
    \caption{Przykłady oznaczania tempa utworu}
    \label{fig:presto}
\end{figure}

Jak widać więc,
faktyczna długość poszczególnych nut podlega dość luźnej interpretacji, zarówno
podczas wykonywania utworu, jak również podczas zapisywania utworu w zapisie nutowym.
Przełożenie nagranych dźwięków na oczekiwane przez użytkownika nuty jest jednym z problemów
z którymi boryka się opisywany w tej pracy program.

O wartości nuty decyduje jej wypełnienie, obecność pionowej laski oraz ilość chorągiewek.
Cała nuta zapisywana jest jako pusta w środku elipsa. Półnuta to cała nuta ozdobiona
pionową laską w górę lub w dół; zwrot jest zależny od pionowej pozycji nuty na pięciolinii, aczkolwiek zazwyczaj jest on dobierany ze mając na względzie walory estetyczne -- nie ma
sztywnych reguł określających, od którego momentu w którą stronę kierowana jest laska.
Ćwierćnuta
ma taki sam symbol jak półnuta, jednak elipsa jest wypełniona. Ósemki, szesnastki itd.
oznaczane są dodawaniem do symbolu ćwierćnuty chorągiewek: jednej w przypadku ósemki,
dwóch dla szesnastki i tak dalej.

Zapisując wiele ósemek lub krótszych nut obok siebie
należy połączyć je belkami w grupy odpowiadające podziałowi metrycznemu utworu:
dla przykładu jeśli podstawową jednostką metryczną w utworze (dolną nutą w oznaczeniu metrum) jest ćwierćnuta,
nuty łączymy w grupy o długości jednej ćwierćnuty (dwie ósemki czy też cztery szesnastki).
Ilość belek odpowiada ilości chorągiewiek dla danego typu nuty. Przykład takiego zapisu widzimy
na rysunku~\ref{fig:belki}. XXX Opis metrum jest dopiero stronę dalej :/

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        g'1 g'2 g'4 g'8 g'16
    }
    \end{lilypond}
    \caption{Różne długości nut. Od lewej: cała nuta, półnuta, ćwierćnuta, ósemka, szesnastka}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        g'8 g'8 g'16 g'16 g'16 g'16
    }
    \end{lilypond}
    \caption{Dwie ósemki i cztery szesnastki połączone belkami}
    \label{fig:belki}
\end{figure}

Obok każdej nuty można zapisać \emph{kropkę}. Kropka oznacza, iż nuta jej odpowiadająca ma
mieć długość o połowę dłuższą -- tak więc ćwierćnuta z kropką ma długość jednej ćwierćnuty i
jednej ósemki.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        g'4.
    }
    \end{lilypond}
    \caption{Ćwierćnuta z kropką}
\end{figure}

Aby zaznaczyć w zapisie nutowym ciszę w utworze używa się \emph{pauz}.
Pauzy mają takie
same długości jak odpowiadające im nuty, nie mają jednak wysokości -- zapisujemy je
w~ustalonych miejscach na pięciolinii.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        r1 r2 r4 r8 r16 r32
    }
    \end{lilypond}
    \caption{Pauzy. Od lewej: całonutowa, półnutowa, ćwierćnutowa, ósemkowa, szesnastkowa}
\end{figure}

Podobnie jak nuty, pauzy również mogą być okraszone kropkami. Zapisu takiego używa się
jednak niezwykle rzadko, zastępując go po prostu dwiema pauzami. Przykład widzimy na
rysunku~\ref{fig:worms_theme} w partii prawej ręki, gdzie pierwsze dwie pauzy możnaby
teoretycznie zastąpić pauzą z kropką. Nie robi się tak jednak ze względów estetycznych.

Podczas gdy wygląd nuty określa długość dźwięku, wysokość tegoż dźwięku jest zależna od pionowej
pozycji nuty na pięciolinii. Nuty mozemy zapisywać albo na liniach, albo pomiędzy nimi:
na pięciolinii jest zatem 11 pozycji na których możemy umieścić nuty (licząc pozycję pod
najniższą oraz nad najwyższą linią). Aby umieścić na pięciolinii większy zakres dźwięków
dopisuje się dodatkowe kreski pod lub nad pięciolinią, zmieniając ją na pewnym odcinku
w niejako „siedmiolinię” bądź „dziewięciolinię” (tak jak na rysunku~\ref{fig:dodane}).

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        c'8 d'8 e'8 f'8 g'8 a'8 b'8 c''8 c''8 d''8 e''8 f''8 g''8 a''8 b''8 c'''8
    }
    \end{lilypond}
    \caption{Przykład linii dodanych}
    \label{fig:dodane}
\end{figure}

W muzyce używamy tylko dźwięków o określonych częstotliwościach, i opisujemy
je literami alfabetu. Dźwięk \begin{math} C_4 \end{math} (czwarty, a zatem środkowy dźwięk C
na standardowej klawiaturze pianina) ma częstotliwość około 261.6 Hz).
\begin{math} D_4 \end{math}, będący dźwiękiem o jeden ton wyższym (następny biały klawisz)
od \begin{math} C_4 \end{math} ma częstotliwość około 293.665 Hz. Różnice częstotliwości między
kolejnymi dźwiękami zmieniają się nieregularnie: nie wynoszą one około 36 Hz jak wynikałoby
z różnicy częstotliwości \begin{math} C_4 \end{math} i \begin{math} D_4 \end{math}.
Dźwięki w kolejnych \emph{oktawach} natomiast mają zawsze częstotliwość około dwa razy większą
niż dźwięk z poprzedniej oktawy. (\begin{math} C_5 \end{math} ma w przyblizeniu dwa razy
większą częstotliwość niż \begin{math} C_4 \end{math} -- 523.251 Hz).

Istnieje wiele notacji zapisu z której oktawy pochodzi dany dźwięk. Do tej pory
używaliśmy \emph{notacji naukowej} (ang. \emph{scientific pitch notation}), ze względu na jej
czytelność oraz fakt, iż dobrze oddaje pozycje dźwięków na klawiaturze pianina.
W formacie Lilypond, który program generuje jako stadium pośrednie generowania arkusza muzycznego
używana jest notacja Helmholtza: \begin{math} C_4 \end{math} zapisujemy
w~niej jako «\begin{math} c' \end{math}», \begin{math} C_2 \end{math} zaś jako
«\begin{math} c, \end{math}».

Indeksy dolne przy nazwach dźwięków mówią nam, z której oktawy pochodzi dźwięk.
Oktawą nazywamy \emph{interwał} o długości 8 dźwięków, czyli odległość między dźwiękiem, a
dźwiękiem leżącym 8 klawiszy dalej na klawiaturze pianina. Na typowej klawiaturze znajduje się
8~oktaw, tak więc znajdują się tam dźwięki z zakresu nie węższego niż od
\begin{math} C_1 \end{math} do \begin{math} C_8 \end{math}. \begin{math} C_1 \end{math} jest
dźwiękiem C znajdującym się najbardziej z lewej (o najniższej częstotliwości),
\begin{math} C_8 \end{math} zaś najbardziej z prawej strony klawiatury.

Widać zatem, że zakres dźwięków na klawiaturze pianina wielokrotnie przewyższa
zakres dźwięków które można zapisać
na pięciolinii.
Aby określić którym dźwiękom odpowiadają które linie używa się \emph{klucza}. Różne klucze
przypisują liniom konkretne dźwięki.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        r2
    }
    \end{lilypond}
    \caption{Klucz wiolinowy (pierwszy symbol od lewej)}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "bass"
        r2
    }
    \end{lilypond}
    \caption{Klucz basowy (pierwszy symbol od lewej)}
\end{figure}

Najczęściej stosowanym kluczem jest \emph{klucz wiolinowy}. Jest on również nazywany
kluczem G: wyznaczany przez niego punkt odniesienia 
znajduje się bowiem na drugiej od dołu linii, która
to linia w~tym oto kluczu odpowiada dźwiękowi \begin{math} G_4 \end{math}. 
\begin{math} C_4 \end{math} znajduje się w kluczu wiolinowym na pierwszej linii dodanej
dolnej, \begin{math} C_5 \end{math} zaś na pozycji pomiędzy trzecią a czwartą linią
(licząc od dołu). Klucz wiolinowy jest niemal zawsze używany przy partii utworu granej
na pianinie prawą ręką.

Klucz basowy (klucz F) jest zazwyczaj używany do zapisu partii lewej ręki: jego górny
koniec wskazuje na dźwięk \begin{math} F_3 \end{math}. Dźwięk \begin{math} C_4 \end{math}
znajduje się na pierwszej linii dodanej górnej, a \begin{math} C_3 \end{math} pomiędzy
drugą a trzecią linią (od dołu).

Zdarza się, że klucz zmienia się w trakcie utworu, zazwyczaj jednak jest on zapisywany
jedynie raz, na samym początku pięciolinii, i pozostaje taki sam przez cały utwór aż
do końca.

Może się również zdarzyć, iż obie ręce będą zapisane w kluczu wiolinowym
(bądź basowym). Występuje to jednak bardzo rzadko, i program nie obsługuje takiego przypadku,
ponieważ w praktyce niezwykle trudne okazałoby się dzielenie na ręce utworu, w którym znajdują
się one bardzo blisko siebie czy nawet zachodzą jedna na drugą. Udostępiona jest jednak możliwość
ręcznej zmiany kluczy w edytorze, co po ręcznym ustawieniu podzielinka rąk umożliwi wygenerowanie
poprawnego arkusza nawet dla tak wyszukanego przypadku.

TODO: Coś o tym, że odległości na pięciolinii to jak białe klawisze w pianinie, czy cuś.

Każdy utwór posiada \emph{metrum}, które definiuje nam jak wiele nut składa się na jeden
\emph{takt}, co umożliwia wykonawcy odpowiednie rozłożenie akcentów. Metrum zapisuje się
zaraz za kluczem za pomocą dwóch liczb. Górna mówi ile nut będzie stanowić jeden takt,
dolna zaś jakiego typu mają być to nuty. O metrum mówi się zwykle tak, jakby było ułamkiem
(więc np. „trzy czwarte” bądź „cztery ósme”), mimo iż ułamkiem nie jest. W szczególności
metrum 4/8 nie jest, jak mogłoby się wydawać, tym samym co 2/4 czy 1/2. Mimo, iż po takim
matematycznym skróceniu długość taktu pozostanie taka sama, zmieni się sugerowane akcentowanie
dźwięków.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        \time 3/4
        d'8 c'8 d'8 e'8 f'8 d'8 | e'8 c'8 g'4 c''4 | b'4 c''4 d''8 g'8 |
    }
    \end{lilypond}

    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        \time 6/8
        d'8 c'8 d'8 e'8 f'8 d'8 | e'8 c'8 g'4 c''4 | b'4 c''4 d''8 g'8 |
    }
    \end{lilypond}
    \caption{Ten sam zapis przed i po „skróceniu” metrum}
\end{figure}


W przypadku generowania arkusza muzycznego akcenty w nagranym utworze nie zawsze będą na tyle
wyraźne, aby poprawnie odgadnąć metrum utworu, toteż opisywany program często decyduje jedynie
pomiędzy metrum 3/4 a 4/4, pozostawiając użytkownikowi możliwość poprawienia na prawidłowe.

Metrum 4/4 zapisuje się zwykle w arkuszach muzycznych znakiem C (jak na rysunku poniżej).

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        g'4 g'4 g'4 g'4
        g'4 g'4 g'4 g'4
    }
    \end{lilypond}
    \caption{Tempo 4/4}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        \time 3/8
        g'8 g'8 g'8
        g'8 g'8 g'8
    }
    \end{lilypond}
    \caption{Tempo 3/8}
\end{figure}

TODO: o tonacjach.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Architektura projektu}
\label{sec:architektura}

Program w ogólności służy do zamieniania sygnału MIDI w reprezentację
graficzną w formie zapisu nutowego.
W praktyce jednak przetwarza on nagrania w formie plików MIDI, a produkuje tekst w formacie
Lilypond
(nazwą którego została zainspirowana nazwa programu: \emph{Lilith}). Zamianą takiego zapisu
na reprezentację graficzną zajmuje się program GNU Lilypond, będący zewnętrzną zależnością
projektu.

Nagrania w formacie MIDI można pozyskać z niemal każdego cyfrowego pianina, bardzo często za
pomocą połączenia USB z komputerem. Dlaczego jednak używamy formatu MIDI, zamiast analizować
nagrania z dowolnego, niekoniecznie cyfrowego instrumentu? Niestety, nawet najbardziej
szczegółowa analiza sygnału dźwiękowego nie zawsze uda się precyzyjnie przełożyć na zbiór
wygrywanych dźwięków, a akustyka instrumentu czy pomieszczenia wpłynie na przekłamania w ich
długości. Problem którym zajmuje się ta praca jest problemem wyznaczenia \emph{sposobu wykonania}
utworu, nie jedynie wyznaczenia jego docelowego brzmienia, potrzebne jest zatem jak najwięcej
informacji, jak najbardziej szczegółowe i prezycyjne dane o wykonaniu źródłowym. Narzędzie
kierowane jest głównie do muzyków, którym próbuje zastąpić żmudne przepisywanie swoich utworów
i aranżacji ręcznie, nie służy zaś do rozpoznawania arbitralnych utworów usłyszanych na
przykład w radiu, toteż format MIDI jest najlepszym kompromisem między wygodą użytkownika a
jakością efektu końcowego.

Wraz z programem dostarczane są dwa narzędzia skierowane do użytkownika
końcowego. Program \texttt{lilith-gtk} implementuje wygodny interfejs użytkownika
używając biblioteki Gtk+\footnote{\url{https://developer.gnome.org/gtk2/stable/}}. Jest on
szczegółowo opisany w~rozdziale~\ref{sec:opis_interfejsu}. Oprócz \texttt{lilith-gtk} dostępny
jest również konsolowy program \texttt{lilith-cli}, pozwalający nieinteraktywnie wygenerować
plik PDF bądź plik w formacie Lilypond z zadanego pliku. Szczegółowy opis obsługi
\texttt{lilith-cli} można uzyskać uruchamiając go z parametrem \texttt{-{}-help}.

Do obu programów dostarczane jest nagranie w formie pliku MIDI. Interfejs
graficzny \texttt{lilith-gtk} dostarcza wprawdzie możliwość nagrania sygnału bezpośrednio
z urządzenia (na przykład pianina cyfrowego), jednakże nawet wtedy nagranie zapisywane
jest do pliku w celu dalszej obróbki przez kolejne elementy programu. Nagrywanie jest realizowane
przez zewnętrzny program \texttt{arecordmidi}. Ponieważ \texttt{arecordmidi} korzysta z systemu
dźwięku ALSA dostępnego tylko pod Linuksem, system ten jest jedyną platformą na której dostępna
jest ta funkcjonalność; pod innymi systemami nagranywanie sygnału z urządzenia nie będzie
możliwe bez zmian w kodzie programu.

Przetwarzanie samego sygnału MIDI jest realizowane za pomocą modułu (biblioteki)
MIDI\footnote{\url{https://metacpan.org/pod/MIDI}}. Moduł ten jest również zewnętrzną zależnością
programu Lilith. Jest używany do sprawdzenia poprawności pliku źródłowego oraz
przetworzenie binarnych danych w nim zawartych na strukturę danych sposobną
do dalszego przetwarzania.

Standard MIDI zawiera obsługę wielu urządzeń i efektów które nigdy nie występują podczas
utworów granych na pianinie, więc też nie wszystkie dane przetworzone przez moduł MIDI
są analizowane przez program. Strumień MIDI może się składać z wielu \emph{ścieżek}, z których
każda zawiera serię \emph{zdarzeń}. Każda ze ścieżek zawiera sygnał
pochodzący z jednego instrumentu, zatem w naszym przypadku interesuje nas tylko jedna ze ścieżek
(jeden instrument), a i spośród zdarzeń będą interesować nas głównie zdarzenia wciskania oraz
puszczania klawiszy: \texttt{note\_on} oraz \texttt{note\_off}. Pozostałe są potrzebne tylko do
wyliczania indeksów czasowych: w MIDI każde zdarzenie jest umiejscowione w czasie relatywnie do
poprzedniego, tak więc podczas przetwarzania kolejnych zdarzeń aktualny indeks czasowy jest
uaktualniany po każdym z nich, aby być w stanie określić, w którym momencie wystąpiły wciśnięcia
i puszczenia klawiszy. Czas jest mierzony nie w jednostkach SI (sekundach),
a w ilości taktów zegara z
urządzenia źródłowego. Przełożenie tegoż na sekundy jest możliwe, jednak ze względu na
fakt, iż długości dźwięków w muzyce nie mają odgórnie określonych długości, mierzenie czasu
w sekundach jest zbędne.

Cała logika programu (a więc implementacja algorytmów przedstawionych
w~rozdiale~\ref{sec:opis_algorytmu} zawarta jest w module \texttt{Lilith} -- programy
\texttt{lilith-gtk} i \texttt{lilith-gtk} są jedynie nakładkami (\emph{frontend}),
i same w sobie nie zawierają kodu odpowiedzialnego za przetwarzanie. Ich jedynym zadaniem
jest zinterpretowanie zamiarów użytkownika i przekazanie pliku wejściowego do modułu
\texttt{Lilith}. Podstawowym interfejsem tego modułu jest funkcja
\texttt{generate}, zamieniającą ciąg zdarzeń MIDI na tekst w formacie Lilypond.
Szczegółowy opis metody tejże zamiany jest zawarty w~rozdziale~\ref{sec:opis_algorytmu}.
Moduł \texttt{Lilith} można również potraktować jako samodzielną bibliotekę i wykorzystać
ją do stworzenia własnego interfejsu, będącego na przykład aplikacją WWW. Szczegółowy opis
API modułu \texttt{Lilith} jest dostępny w formacie
POD\footnote{\url{http://perldoc.perl.org/perlpod.html}}, możliwym do odczytania na przykład
za pomocą narzędzia \texttt{perldoc}. (TODO: wcale nie jest, nie ma jeszcze żadnej dokumentacji
API)

Wyjściem modułu \texttt{Lilith} jest zapis nutowy w formacie GNU Lilypond.
W przypadku żądania wygenerowania dokumentu w formacie PDF używany jest zewnętrzny program
\texttt{lilypond}, będący zależnością projektu.

Program został napisany i testowany na systemie Linux. O ile sam moduł \texttt{Lilith} nie
korzysta z niczego, co przeszkadzałoby w uruchomieniu go na przykład na systemie Windows,
o tyle jego interfejs w Gtk jest w zasadzie nieprzenośny.
Dostosowanie \texttt{lilith-gtk} do pracy pod Windows (być może w pewnym tylko
stopniu) jest możliwe, nie zostało to jednak zrealizowane w ramach tego projektu. Pod niemal
każdym systemem Uniksowym (Perl jest dostępny na ponad 100 różnych platform) program powinien
działać w bez dodatkowych zabiegów (z wyjątkiem opisywanego wcześniej nagrywania przy pomocy
\texttt{arecordmidi}.


\newpage
\section{Opis algorytmu}
\label{sec:opis_algorytmu}

Opisany w niniejszym rozdzialne proces ma na celu przedstawienie w jaki
sposób prymitywne i niskopoziomowe zdarzenia zawarte w strumieniu MIDI
są zamieniane na czytelny i zrozumiały dla użytkownika zapis nutowy.

Zadanie polega zatem nie tylko na poprawnym przełożeniu sekwencji
naciskanych klawiszy odczytanych z MIDI na \emph{nuty} o odpowiedniej
\emph{długości} i \emph{wysokości}, ale również na swoistym odgadnięciu
zamiarów użytkownika i wygenerowanie takiego arkusza, który zagrany na
instrumencie będzie odpowiadał dźwiękom uprzednio nagranym, ale również
będzie wyglądał przejrzyście i będzie łatwy do śledzenia wzrokiem
podczas grania.

Tak jak kod źródłowy w języku programowania można formatować w różny
sposób aby wpłynąć na jego czytelność, tak samo można wygenerować wiele
arkuszy muzycznych dla tego samego utworu -- wszystkie równoważne, acz
nie każdy z nich tak samo łatwy do odczytania.

W poniższych podrozdziałach opisane zostaną szczegółowo kolejne kroki
algorytmu, w takiej kolejności w jakiej są one wykonywane w programie.

\subsection{Określenie tonacji utworu}

\emph{Tonacja} utworu określana jest metodą statystyczną; liczone są ilości
wystąpień każdego dźwięku w utworze, a następnie na podstawie tego,
które z nich występują najczęściej odgadywana jest prawdopodobna tonacja
wykonywanego utworu.


Z każdego zdarzenia \texttt{note\_on}\footnote{wszystkie użyte nazwy
zdarzeń odpowiadają API modułu MIDI} w strumieniu MIDI pobierany jest
indeks klawisza. Ponieważ nieistotne jest, w której \emph{oktawie}
znajduje się dźwięk, są one wszystkie normalizowane do najniższej oktawy
(indeksy od 0 do 12).

Zdarzenia \texttt{note\_off} są ignorowane; zawsze będzie ich dokładnie
tyle samo, co \texttt{note\_on}, a na tym etapie nie dostarczają nam
żadnej wartościowej informacji.

% PRZYKŁAD ???
Mając przygotowaną mapę częstotliwości dzięków, sprawdzane jest, które
z nich są podwyższone bądź obniżone; ma to na celu wyznaczenie
prawdopodobnych znaków przykluczowych, co niemal jednoznacznie przekłada
się na tonację utworu. Przykładowo, jeśli w utworze częściej występuje
dzwięk F\# niż F, oraz C\# częściej niż C, mamy do czynienia z tonacją
D-dur bądź h-moll. Dokładne określenie o którą z nich chodzi może być z
pewnym przybliżeniem określone na podstawie dźwięków kończących
utwór (Nie jest to jednak zaimplementowane. TODO?).

Krok ten możnaby w zasadzie wykonać w dowolnym innym momencie
(przed wygenerowaniem zapisu w formacie Lilypond), tudzież
równolegle z pozostałymi krokami; żaden z pozostałych kroków algorytmu
nie korzysta z informacji o tonacji utworu.

Powyższy algorytm okazuje się działać praktyczne bezbłędnie dla
wszystkich testowanych utworów; jedynym wyjątkiem jest sytuacja, gdy
tonacja utworu zmienia się w trakcie jego trwania: zdarza się, iż utwór
ma refren grany w innej tonacji, niż zwrotkę\footnote{Przykładem jest
\emph{Still Alive} Jonathana Coultona}. Algorytm owocuje wówczas
częściowo poprawnym rozwiązaniem, będącym zazwyczaj pod- lub nadzbiorem
obu tonacji. Nie jest to na szczęście wielki problem: tonacja jest
trywialna do poprawienia w zapisie Lilypond, a nawet bez takiej poprawki
poszczególne nuty niepasujące do odgadniętej tonacji będą oznaczone
[krzyżykami lub bemolami: jak to się nazywa? FIXME], toteż zapis nutowy
pozostanie poprawny.

\subsection{Określanie długości i wysokości nut}

Każda nuta w zapisie nutowym posiada zarówno wysokość, określoną przez
jej wertykalną pozycję na pięciolinii i oznaczającą, jak sama nazwa
wskazuje wysokość opisywanego dźwięku, jak i długość tegoż, o czym w
reprezentacji graficznej mówi nam wypełnienie kropki oraz kształt jej
„ogonka” (bądź jego brak). Na tym etapie nie jest jeszcze produkowana
graficzna reprezentacja nut, produkowane są natomiast struktury danych
przechowujące obie te informacje w celu dalszego przetwarzania.

Określenie wysokości każdej nuty jest zadaniem trywialnym: indeks każdego
klawisza zapisany w strumieniu MIDI odpowiada jednoznacznie dźwiękowi
który się za nim kryje (przykładowo klawisz numer 62 jest zawsze
odpowiednikiem dźwięku \begin{math} C_4 \end{math}).

Długość dźwięków nie jest już jednak sprawą tak prostą.
MIDI dostarcza nam informacji o tym, kiedy który klawisz został naciśnięty
oraz kiedy został puszczony. Na podstawie analizy zdarzeń takich jak
\texttt{set\_tempo} oraz zapisanego w każdym zdarzeniu przesunięcia
czasowego możemy nawet wyliczyć, ile milisekund był grany każdy z dźwięków.
Niestety, nawet tak dokładna informacja nie ma w praktyce żadnego przełożenia
na wartości których szukamy. Długość nut w utworze nie jest bowiem wyrażana
w jednostkach SI, a jest ona relatywna do innych nut. Mamy zatem całe nuty:
nuty o pełnej długości, a nastepnie półnuty, ćwierćnuty i tak dalej. Nie
istnieje referencyjna długość całej nuty: dla każdego utworu będzie ona nieco
inna, zależna od tempa utworu.

Jak zatem przełożyć długości dźwięków na długości nut? Jedynym wyjściem jest
posłużenie się heurystyką -- wyznaczenie długości nut dla różnych
[czasów? Jak to powiedzieć?], a następnie wybranie takiego wyniku który wydaje
się najbardziej prawdopodobny. W dalszej części tego podrozdziału zostanie
dokładnie opisane, w jaki sposób cząstkowe wyniki są oceniane, na razie skupmy
się jednak na metodzie dochodzenia do każdego z nich.

Długości nut są wyliczane metodą próbkowania. Wybieramy odgórnie długość jednej
trzydziestodwójki (1/32 całej nuty), i dla każdego takiego okna czasowego
notujemy wszystkie dźwięki które w nim brzmią (tj. zaczynają się w tym lub
wcześniejszym oknie czasowym, i kończą w tym bądź późniejszym). Jedna ósemka
zostanie wówczas „zauważona” czterokrotnie, ćwierćnuta ośmiokrotnie i tak dalej.
Dla przedziałów czasowych które pozostały puste wstawiamy \emph{pauzy}, na takiej
samej zasadzie jak nuty (otrzymując pauzy ósemkowe, ćwierćnutowe etc). Po przeanalizowaniu
w ten sposób całego utworu przeszukujemy otrzymaną listę nut od początku do końca,
każdy znaleziony dźwięk „sklejając” z jego ponownymi wystąpieniami i zapisując
dla niego odpowiadającą mu długość.

Na rysunku~\ref{fig:polling1} widzimy efekt próbkowania piosenki „Wlazł kotek na płotek”
dla rozdzielczości 300. Nuta numer 4 zawarła się w przedziałach od piątego do siódmego,
nuta numer 8 zaś w~przedziałach od dziesiątego do jedenastego. Nuta numer 4 jest zatem
w przybliżeniu o połowę dłuższa niż nuta numer 8.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \begin{axis}[
        grid=major,
        legend pos=outer north east,
        legend cell align=left,
        xtick={0,300,...,3600},
        x tick label style={rotate=45,anchor=east,font=\tiny},
    ]
    \addplot coordinates { (0,    67) (514,  67) };
    \addplot coordinates { (470,  64) (867,  64) };
    \addplot coordinates { (909,  64) (1399, 64) };
    \addplot coordinates { (1356, 65) (1832, 65) };
    \addplot coordinates { (1794, 62) (2175, 62) };
    \addplot coordinates { (2235, 62) (2612, 62) };
    \addplot coordinates { (2682, 60) (2889, 60) };
    \addplot coordinates { (2888, 64) (3155, 64) };
    \addplot coordinates { (3129, 67) (3516, 67) };
    \legend{
        1. $G_4$ (wlazł),
        2. $E_4$ (ko),
        3. $E_4$ (tek),
        4. $F_4$ (na),
        5. $D_4$ (pło),
        6. $D_4$ (tek),
        7. $C_4$ (i),
        8. $E_4$ (mru),
        9. $G_4$ (ga),
    }
    \end{axis}
    \end{tikzpicture}
    \caption{Przykładowy efekt próbkowania piosenki „Wlazł kotek na płotek”}
    \label{fig:polling1}
\end{figure}

W praktyce dobierane rozdzielczości są dużo mniejsze -- optymalną rozdzielczością dla
przykładu z rysunku~\ref{fig:polling1} jest 41, dla której możemy precyzyjnie określić
długość nut i otrzymać zadowalający wynik końcowy. Wykres dla takiego próbkowania
jest widoczny na rysunku~\ref{fig:polling2}.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \begin{axis}[
        grid=major,
        legend pos=outer north east,
        legend cell align=left,
        xtick={0,41,...,3600},
        xticklabels={,,}
    ]
    \addplot coordinates { (0,    67) (514,  67) };
    \addplot coordinates { (470,  64) (867,  64) };
    \addplot coordinates { (909,  64) (1399, 64) };
    \addplot coordinates { (1356, 65) (1832, 65) };
    \addplot coordinates { (1794, 62) (2175, 62) };
    \addplot coordinates { (2235, 62) (2612, 62) };
    \addplot coordinates { (2682, 60) (2889, 60) };
    \addplot coordinates { (2888, 64) (3155, 64) };
    \addplot coordinates { (3129, 67) (3516, 67) };
    \legend{
        1. $G_4$ (wlazł),
        2. $E_4$ (ko),
        3. $E_4$ (tek),
        4. $F_4$ (na),
        5. $D_4$ (pło),
        6. $D_4$ (tek),
        7. $C_4$ (i),
        8. $E_4$ (mru),
        9. $G_4$ (ga),
    }
    \end{axis}
    \end{tikzpicture}
    \caption{„Wlazł kotek na płotek” przy optymalnym próbkowaniu}
    \label{fig:polling2}
\end{figure}

Co jednak z dźwiękami nieco dłuższymi lub krótszymi niż być powinny? Grając
np. półnuty lub całe nuty nietrudno przypadkiem przeciągnąć trochę dźwięk
i~zagrać go o~jedną trzydziestodwójkę za krótko lub za długo. Algorytm
bierze to pod uwagę, i zaokrągla każdą nutę do najbliższej sensownej wartości,
kompensując w ten sposób niedokładność wykonania utworu przez człowieka.

\begin{figure}[h!]
    \centering
    \begin{tabular}{ | c | c | c | c | }
    \hline
    Lp. & Dźwięk & Ilość przedziałów & Długość nuty \\ \hline
    1. & \begin{math} G_4 \end{math} & 12 & 1/4 \\ \hline
    2. & \begin{math} E_4 \end{math} & 10 & 1/4 \\ \hline
    3. & \begin{math} E_4 \end{math} & 12 & 1/4 \\ \hline
    4. & \begin{math} F_4 \end{math} & 11 & 1/4 \\ \hline
    5. & \begin{math} D_4 \end{math} &  9 & 1/4 \\ \hline
    6. & \begin{math} D_4 \end{math} & 10 & 1/4 \\ \hline
    7. & \begin{math} C_4 \end{math} &  5 & 1/8 \\ \hline
    8. & \begin{math} E_4 \end{math} &  7 & 1/8 \\ \hline
    9. & \begin{math} G_4 \end{math} & 10 & 1/4 \\ \hline
    \end{tabular}
    \caption{Wyznaczone długości nut dla rozdzielczości 41}
    \label{fig:mapping41}
\end{figure}

Jak widzimy na rysunku~\ref{fig:mapping41}, nuty pokrywające poniżej 8 przedziałów zostały
sklasyfikowane jako ósemki, te powyżej zaś jako ćwierćnuty. (Wynik w postaci graficznej
jest widoczny na rysunku~\ref{fig:wlazkotekgood}).

Opisany powyżej algorytm nie jest w stanie precyzyjnie
wychwycić dźwięków krótszych niż trzydziestodwójki; występują one jednak
niezwykle rzadko; w praktyce jeśli trafiają się one w utworze, możemy
bezpiecznie założyć iż dobraliśmy zbyt małą częstotliwość próbkowania dla
analizowanego utworu.

Metoda ta okazuje się działać znakomicie, pod warunkiem dobrania odpowiedniej
częstotliwości próbkowania dźwięków. Jak zatem wyznaczyć ją \emph{a priori},
przed rozpoczęciem analizy utworu, aby wynik był akceptowalny?
Tutaj własnie pojawia się heurystyka;
opisaną wyżej procedurę wykonujemy wielokrotnie, dla wielu różnych długości
jednej trzydziestodwójki, a następnie spośród otrzymanych wyników cząstkowych
wybieramy ten najlepszy.

Jak jednak ocenić, który z nich jest najlepszy?
Specjalna funkcja oceny analizuje każdy z otrzymanych wyników, i przyznaje mu
punkty karne za każdą „niemile widzianą” strukturę dźwięków.
Funkcja ta przyzna zatem punkty karne za każdy dźwięk krótszy niż 1/32, tudzież
dłuższy niż cała nuta: oba ta przypadki świadczą o zbyt małej lub zbyt dużej
częstotliwości próbkowania dla danego wyniku. Jest to dobra metoda do
wyeliminowania skrajnych przypadków, co jednak z bardziej subtelnymi błędami?

Pianista grający utwór nigdy nie zagra ich perfekcyjnie, z mechaniczną precyzją,
i długością nut dokładną co do milisekundy. Długość np. ósemki może wahać się
w nagranym utworze pomiędzy, przyjmijmy, 35 a 45 tyknięciami zegara. Co stanie
się wówczas dla rozdzielczości próbkowania równej 10 (10 dla jednej
trzydziestiodwójki da nam 40 dla jednej ósemki)? Połowa tych nut zostanie
zakwalifikowana jako ósemki, połowa zaś błędnie jako ćwierćnuty. W efekcie
otrzymamy zapis utworu w którym zamiast serii równych ósemek otrzymamy ciąg ósemek
poprzeplatanych ćwierćnutami.

Aby wystrzec się powyższego przypadku, funkcja oceny kara każdą nutę o długości
innej, niż poprzednia. Wówczas seria równych ósemek (które otrzymamy na przykład
dla rozdzielczości 12 lub wyższej) otrzyma mniej punktów karnych niż
„przeplataniec” opisany powyżej.

Inną rzeczą poprawną, acz nietypową w zapisie nutowym są \emph{nuty z kropkami}.
Dźwięk mający długość trzech ósemek, a zatem półtorej ćwierćnuty
zapisujemy za pomocą ćwierćnuty z kropką (kropkę możemy wówczas odczytać jako
przyrostek „i pół”). Takie nuty występują niemal w każdym utworze, tym niemniej
nie należą one do większości. Jeśli utwór zawiera więcej nut z kropkami niż bez
(a już tym bardziej pauz z kropkami, które w utworach nie występują niemal
 nigdy), zapis możemy bezpiecznie uznać za niedoskonały.

Możliwość wystąpienia takiego przypadku możemy zilustrować kolejnym przykładem:
załóżmy że analizujemy utwór dla rozdzielczości 10 (czyli idealną długością
ćwierćnuty byłoby 80), a wszystkie nuty w utworze mają długość oscylującą wokół
120, algorytm radośnie wyprodukuje nam serię ćwierćnut z kropkami, podczas gdy
dla rozdzielczości 15 długość ćwierćnuty wyniosłaby dokładnie 120, i wszystkie
wykryte nuty zostałyby wykryte jako ćwierćnuty. Oba dostarczone wyniki byłyby
oczywiście poprawne i równoważne, niemniej jednak trudno wyobrazić sobie
kompozytora, który celowo wstawia w utwór same nuty z kropkami (chociażby
przez trudność utrzymania \emph{tempa} utworu, \emph{akcentów} i długości
\emph{taktów}. Funkcja oceny kara zatem wystąpienia nut z kropkami, aby dać
szansę tym wynikom, w których występuje ich jak najmniej.

Funkcję oceny możemy zapisać zatem następująco:

\begin{math}
    h(x) = 2x_1 + 5x_2 + x_3
\end{math}

Gdzie \begin{math} x_1 \end{math} to ilość zmian długości nut,
\begin{math} x_2 \end{math} to ilość dźwięków krótszych niż 1/32,
\begin{math} x_3 \end{math} zaś to ilość nut z kropkami. Współczynniki
zostały dobrane metodą prób i błędów w celu zapewnienia najlepszych
rezultatów.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        \time 3/4
        g'4 e'4 e'4 | f'4 d'4 d'4 | c'8 e'8 g'4 r4 | 
        g'4 e'4 e'4 | f'4 d'4 d'4 | c'8 e'8 c'4 r4 |
    }
    \end{lilypond}
    \caption{Dobry zapis „Wlazł kotek na płotek” (rozdzielczość 41)}
    \label{fig:wlazkotekgood}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    {
        \key c \major
        \clef "treble"
        \time 3/4
        g'4. e'4 e'4. | f'4. d'4 d'4 | c'8 e'8 g'4 r4. | 
        g'4. e'4 e'4. | f'4. d'4 d'4. | c'8 e'8 c'4
    }
    \end{lilypond}
    \caption{Zły zapis „Wlazł kotek na płotek” (rozdzielczość 35)}
    \label{fig:wlazkotekbad}
\end{figure}

Policzmy teraz wartość funkcji oceny dla przykładów z rysunków 4 i 5.
Na rysunku~\ref{fig:wlazkotekgood} widzimy jedynie 4 zmiany tempa:
nie ma na nim ani nut z kropkami
ani dźwięków krótszych niż 1/32 (widocznych w zapisie nutowym jako ozdobniki),
toteż wartość funkcji wynosi
\begin{math}
    h(x) = 2 * 4 + 5 * 0 + 0 = 8
\end{math}

Na rysunku~\ref{fig:wlazkotekbad} sytuacja jest bardziej skomplikowana:
widocznych jest 12 zmian tempa,
8 nut (bądź pauz) z kropkami, oraz ponownie zero nut krótszych niż 1/32. Funkcja oceny
wynosi zatem
\begin{math}
    h(x) = 2 * 12 + 5 * 0 + 8 = 32
\end{math}

Zgodnie z oczekiwaniami rysunek~\ref{fig:wlazkotekgood} otrzymuje dużo mniejszą karę
niż rysunek~\ref{fig:wlazkotekbad},
zostaje zatem wybrany  jako lepszy wynik końcowy.

Oprócz heurystycznej metody dobrania rozdzielczości użytkownik ma również
możliwość ręcznego ustawienia rozdzielczości w interfejsie programu.

Po zastosowaniu powyższych kroków i wybraniu najlepiej w oczach funkcji oceny
wyglądającego wyniku otrzymujemy zapis nutowy będący bardzo dobrym
odzwierciedleniem nagranego utworu.

\subsection{Podział na ręce}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    upper = {
        \key g \major
        \clef "treble"
        d''4 g'8 a'8 b'8  c''8 d''4 | g'4 g'4 e''4 c''8 d''8 |
        e''8 fis''8 g''4    d''8 c''8 b'8 a'8 | 
    }
    lower = {
        \key g \major
        \clef "bass"
        << g2 d'2 b2 >>    a4  | b2. |   c'2.  |   b2. 
    }
    \score {
        \new PianoStaff <<
            \time 3/4
            \new Staff = "upper" \upper
            \new Staff = "lower" \lower
        >>
        \layout { }
    }
    \end{lilypond}
    \caption{Przykład zapisu utworu na dwie ręce}
\end{figure}

Jako że utwory na fortepianie grane są (niemal zawsze) dwiema rękami, dla
wygody wykonawcy każda ręka zapisana jest na arkuszu nutowym oddzielnie. Obie
„ręce” grane są równocześnie, toteż i dźwięki zapisane w MIDI nakładają się na
siebie niezależnie od tego, z której ręki pochodzą
(informacja nie jest zawarta w strumieniu MIDI). Jak zatem podzielić otrzymany
ciąg dźwięków na partię lewej i prawej ręki? Program robi to na dwa sposoby
spośród których heurystycznie wybiera ten wyglądający lepiej.

Pierwsza metoda, nazwana metodą „prostą”, dobiera jeden z klawiszy jako
podzielnik (np. standardowe C), a następnie wszystkie dźwięki poniżej tegoż
zapisuje prawej ręce, z pozostałe lewej (pauzy trafiają do obu rąk równocześnie).
Podzielnik jest, podobnie jak w przypadku rozdzielczości przy wyznaczaniu długości
nut, dobierany wielokrotnie, aby następnie w wyników cząstkowych na podstawie
funkcji oceny wybrać ten najlepszy.

Druga metoda, nazwana metodą „śledzącą” nie ma sztywnego podzielnika według
którego dzieli nuty. Zamiast tego, jak sama nazwa wskazuje, śledzi ruchy rąk na
klawiaturze w każdym momencie trwania utworu, i przypisuje dźwięki do tej ręki,
która w danej chwili znajduje się bliżej klawisza odpowiadającemu aktualnie
przetwarzanej nucie. Po każdym przypisaniu nuty do ręki pozycja ręki jest oczywiście
uaktualniana. Metoda ta zdaje egzamin w utworach, w których obu rękom zdarza się
przekraczać nawet najlepiej dobrany w metodzie prostej podzielnik.

Początkową pozycją rąk jest odpowiednio oktawa niżej oraz oktawa wyżej podzielnika,
który dobierany jest wielokrotnie podobnie jak w metodzie prostej
(TODO: wcale nie jest, jak wyżej).

Na koniec z obu metod podziału na ręce wybierana jest ta dająca lepszy wynik.
Funkcja oceny jakości wyniku liczy sumaryczną długość nut w obu rękach, a następnie
przyznaje punkty karne w ilości różnicy długości partii obu rąk -- idealnym
rozwiązaniem jest wówczas to, w którym partie obu rąk mają równą długość.
Wyjątkiem jest przypadek, gdy partia jednej z rąk ma długość zerową, co zdarza się
w przypadku prostych utworów, takich jak opisywany wcześniej „Wlazł kotek na płotek”
-- najlepszym wynikiem jest wówczas ten, kiedy algorytm dobierze taki
podzielnik rąk, że wszystkie nuty w utworze zostaną przydzielone do jednej ręki.
Przypadki takie nie są karane ze względu na różnicę w długości partii.

% TODO: Tak samo opis funkcji oceny jak poprzednio

Dodatkowo karane są te wyniki, w których ręce przekraczają barierę standardowego C:
jeśli dzieje się to zbyt często, dźwięki te są prawdopodobnie źle sklasyfikowane,
toteż za każdy półton o który dźwięk przekracza \begin{math} C_5 \end{math}
do funkcji oceny dodawany jest jeden punkt.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    upper = {
        \key c \major
        \clef "treble"
        e'4 f'4 g'4 a'4
    }
    lower = {
        \key c \major
        \clef "bass"
        b4 c'4 b4 c'4
    }
    \score {
        \new PianoStaff <<
            \time 4/4
            \new Staff = "upper" \upper
            \new Staff = "lower" \lower
        >>
        \layout { }
    }
    \end{lilypond}
    \caption{Przykład dobrego podziału rąk (wokół dźwięku D5, 0 punktów karnych)}
    \label{fig:podzial_dobry}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{lilypond}
    upper = {
        \key c \major
        \clef "treble"
        g'4 a'4 r4 r4
    }
    lower = {
        \key c \major
        \clef "bass"
        << b4 e'4 >> << c'4 f'4 >> b4 c'4
    }
    \score {
        \new PianoStaff <<
            \time 4/4
            \new Staff = "upper" \upper
            \new Staff = "lower" \lower
        >>
        \layout { }
    }
    \end{lilypond}
    \caption{Przykład złego podziału rąk (wokół dźwięku Fs5, 9,5 punktów karnych)}
    \label{fig:podzial_zly}
\end{figure}

W przykładzie z~rysunku~\ref{fig:podzial_zly} widzimy 2 dźwięki,
\begin{math} E_5 \end{math} oraz \begin{math} F_5 \end{math} które znalazły się nie w tej
ręce, w której powinny. Pomiędzy tymi dźwiękami, a \begin{math} C_5 \end{math} jest odpowiednio
4 i 5 półtonów, co razem daje nam 9 punktów karnych. Dodatkowo, w~rysunku~\ref{fig:podzial_zly}
partia lewej ręki (na dole zapisu)
jest o półnutę (dwie ćwierćnuty) krótsza niż partia prawej ręki, toteż zapis ten otrzymuje
dodatkowo pół punktu karnego. Zapis z~rysunku~\ref{fig:podzial_dobry} ma zatem o 9,5 punktu
lepszy wynik, niż ten z~rysunku~\ref{fig:podzial_zly}, jest więc wybrany jako ten lepszy.

\subsection{Określenie tempa utworu}

\subsection{Dynamika}

\section{Opis interfejsu i obsługi programu}
\label{sec:opis_interfejsu}

W poniższym rozdziale opisany zostanie interfejs programu oraz zostaną przedstawione
dwa przykłady konwersji utworów na zapisy nutowe.

Na rysunku~\ref{fig:screenshot1} widzimy interfejs powitalny programu. Na jego szczycie (1)
widzimy belkę z menu. Sekcja \texttt{File} pozwoli nam na wyeksportowanie rezultatu
do pliku PDF bądź zapisanie jego reprezentacji w formacie Lilypond do dalszej obróbki.
W sekcji \texttt{Edit} mamy znajome opcje \texttt{Undo} oraz \texttt{Redo} do edytora tekstu,
dostępne również w formie skrótów klawiszowych \texttt{Ctrl+Z} i \texttt{Ctrl+Shift+Z}.
Sekcja \texttt{Help} zawiera odnośnik do strony internetowej ze szczegółowym opisem formatu
Lilypond oraz możliwość otwarcia okna z informacjami o programie i autorze.

Poniżej menu znajduje się pole tekstowe (2) zawierające nazwę aktualnie analizowanego pliku. Plik
ten możemy otworzyć za pomocą znajdującego się z prawej strony przycisku \texttt{Open} lub też
utworzyć nagranie prosto z instrumentu klawiszowego za pomocą leżącego tamże przycisku
\texttt{Record} (3).

W następnej kolejności interfejs zawiera serię pól tekstowych oraz pole wyboru za pomocą których
możemy zmienić parametry analizatora. Nie warto jednak robić tego przed załadowaniem nagrania --
pola te zostaną automatycznie wypełnione po otwarciu pliku parametrami które analizator wybrał
przetwarzając utwór. Bardzo często nie będą one wymagać żadnych zmian ze strony użytkownika.

Pole obok znacznika \texttt{Tempo} (4) zawiera metrum utworu;
\texttt{Hand division method} (5) pozwala
nam wybrać między dwoma metodami podziału utworu na ręce, \texttt{Hand divisor} (6) daje nam
możliwość ręcznego wybrania podzielnika rąk w obu metodach, zaś wreszczie \texttt{Resolution} (7)
zawiera wybraną rozdzielczość próbkowania sygnału MIDI.

Największą część okna programu zawierają dwa panele: po prawej stronie znajduje się miejsce na
wygenerowany zapis utworu w formie graficznej (11). Z lewej strony zaś widnieje miejsce na
reprezentację tegoż utworu w formacie Lilypond (9), przycisk (8) zlecający programowi odświeżenie
widoku utworu na prawym panelu (generowanie podglądu jest wykonywane w tym
samym wątku, co interfejs programu, jednak nawet na słabszych komputerach proces ten nie trwa
dłużej niż kilka sekund, więc nie będzie do stanowić problemu dla użytkownika),
a także, pod edytorem, interfejs dla wbudowanego mechanizmu
\emph{Search \& Replace} (10). W polu opisanym \texttt{Pattern} umieszczamy wzorzec który będzie
szukany, w \texttt{Replacement} zaś tekst który ma być wstawiony zamiast odnalezionych wystąpień
wzorca. Użyteczną informacją może okazać się fakt, iż w \texttt{Pattern} możemy umieścić dowolne
wyrażenie regularne z języka Perl -- co więcej, w \texttt{Replacement} może znaleźć się dowolny
kod Perla modyfikujący wynik dopasowania takiego wyrażenia. Możemy zatem na przykład zamienić
wszystkie liczby na dwa razy większe wprowadzając \texttt{(\textbackslash{}d+)} jako wzorzec i
\texttt{\$1~*~2} jako tekst to wstawienia.

Ewaluowanie kodu wpisanego w programie
można uznać za lukę bezpieczeństwa, jednak w praktyce nie stanowi ona żadnego zagrożenia. Do
eskalacji uprawnień mogłoby dojść jedynie wtedy, gdyby program był uruchamiany z uprawnieniami
administratora, a wówczas zagrożenie stanowiłbym sam fakt, że program zawiera w sobie edytor
tekstu mogący otwierać i zapisywać pliki, co użytkownik mógłby wykorzystać na przykład w celu
podmiany plików systemowych. Przy prawidłowo skonfigurowanym systemie jednak jedynym
zastosowaniem „luki” byłoby wywołanie błędu w uruchamianym programie (i to też w ograniczonym
zakresie, ponieważ wszystkie wyjątki mogące wystąpić w kodzie wpisanym z
interfejsu są obsługiwane, a komunikaty o błędach są wypisywane na ekran (w ramce
\texttt{CLI Output}). W połączeniu z faktem, iż program jest dystrybuowany w formie skryptu
Perla, z kodem źródłowym dostępnym dla każdego użytkownika mającego do niego dostęp sprawia,
że wywoływanie kodu w ten sposób nie stanowi żadnego niebezpieczeństwa.

Niemal na samym dole ekranu znajduje się pole \texttt{CLI output} (12), zazwyczaj zwinięte.
W przypadku błędów we wpisanym przez użytkownika zapisie w formacie Lilypond, bądź też
nieoczekiwanych błędów wewnętrznych programu pole to rozwija sie i wypełnia komunikatem
o błędzie.

Ostatnim elementem jest pasek statusu (13), który wyświetla informacje o przebiegu działania
programu.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot1.png}
    \caption{Interfejs powitalny programu}
    \label{fig:screenshot1}
\end{figure}

Zobaczmy zatem jak program sprawdza się w akcji. Załadujmy do programu nagranie wykonania
popularnej piosenki „Wlazł kotek na płotek”, znajdującej się w pliku
\texttt{samples/wlazkotek.mid}. Możemy użyć do tego przycisku \texttt{Open}, lub wybrać
odpowiednią pozycję z menu -- efekt będzie taki sam.

Na rysunku~\ref{fig:screenshot2} widzimy fragment okna programu zaraz po załadowaniu pliku.
Jak widać, pola z górnej części okna zostały uaktualnione informacjami wydedukowanymi przez
program: metrum zostało wyznaczone na 3/4, program użył metody śledzącej celem ustalenia podziału
rąk (w tym akurat przypadku program doszedł za pomocą tej metody do poprawnego wniosku, iż
utwór był grany jedną ręką), wybrał \begin{math} C_5 \end{math} jako podzielnik rąk, oraz
wybrał 42 jako rozdzielczość próbkowania sygnału MIDI.

Zapis utworu w formacie Lilypond został umieszczony w oknie edytora, zaś ten sam zapis
skompilowany do postaci graficznej widzmy po prawej stronie edytora.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot2.png}
    \caption{Fragment interfejsu po załadowaniu pliku \texttt{samples/wlazkotek.mid}}
    \label{fig:screenshot2}
\end{figure}

Utwór został w zasadzie bezbłędnie przełożony na odpowiadający mu zapis nutowy. Można jednak
zauważyć, iż ostatni takt utworu jest niepełny. Na jego końcu powinna znajdować się pauza
ćwierćnutowa. W formacie MIDI cisza nie jest oznaczona w żaden inny sposób niż brakiem sygnału,
toteż cisza na końcu utworu jest z definicji niemożliwa do wykrycia. Taką brakującą pauzę możemy
jednak łatwo dopisać, dodając \texttt{r4} na koniec zapisu w edytorze Lilypond. Po zatwierdzeniu
zmian poprzez kliknięcie \texttt{Generate music sheet} otrzymujemy widoczną
na~rysunku~\ref{fig:screenshot3} finalną wersję „Wlazł kotek na płotek”. Możemy teraz
wyeksportować cały zapis do formatu PDF za pomocą opcji \texttt{Export to PDF} z menu
\texttt{File}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot3.png}
    \caption{Fragment interfejsu po dodaniu pauzy na końcu utworu}
    \label{fig:screenshot3}
\end{figure}

Po zaznajomieniu się z podstawami zobaczmy jak poradzić sobie z bardziej skomplikowanym utworem,
którego nagranie zawiera pewne błędy wykonawcy.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{menuet_orig.jpg}
    \caption{Oryginalny zapis nutowy Menueta G-dur BMW.Anh.114 Jana Sebastiana Bacha}
    \label{fig:menuet_orig}
\end{figure}

Na rysunku~\ref{fig:menuet_orig} widzimy oryginalny zapis \emph{Menueta G-dur BMW.Anh.114}
autorstwa Jana Sebastiana Bacha\footnote{Zapis ten jest zawarty w książce
„50 Greats for the Piano”, Copyright \copyright{}2000 by YAMAHA MUSIC MEDIA CORPORATION}.
Po nagraniu i załadowaniu utworu ukazuje nam się obraz widoczny na~rysunku\ref{fig:screenshot4}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot4.png}
    \caption{Wynik załadowania menueta do programu}
    \label{fig:screenshot4}
\end{figure}

Jak nietrudno zauważyć, wygenerowany zapis znacząco odbiega od pierwowzoru. Zobaczmy, jak wiele
zmian będzie potrzebnych aby otrzymać identyczny zapis jak ten, z którego grany był utwór.

Najbardziej widoczną rzeczą jest niepoprawny podział utworu na ręce; widzimy, że algorytm wybrał
dźwięk \begin{math} C_5 \end{math} jako podzielnik rąk (w notacji używanej przez Lilypond jest
on zapisanywany jako \texttt{c'}). Wybierając zamiast niego dźwięk
\begin{math} D\sharp \end{math} (\texttt{dis'} w notacji Lilypondowej) otrzymamy dużo lepszy
i bardziej zgodny z oczekiwaniami wynik widoczny na~rysunku~\ref{fig:screenshot5}.

Warto zaznaczyć, że podzielnik możemy podać do interfejsu w jednej z wybranych dowolnie trzech
notacji: możemy zapisać go jako \texttt{Ds5}, wspomniane wyżej \texttt{dis'} czy
nawet podając indeks klawisza (w tym przypadku 63); każda z tych form zostanie jednakowo
zinterpretowana przez program.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot5.png}
    \caption{Menuet po poprawieniu podzielinka rąk}
    \label{fig:screenshot5}
\end{figure}

Następną rzeczą wartą poprawienia jest zmiana metrum utworu: zostało ono niepoprawnie wykryte
jako 4/4 zamiast 3/4, być może przez błędny pierwotny podział rąk. Można je jednak łatwo poprawić
wpisując 3/4 w polu \texttt{Tempo} i zatwierdzając klawiszem \texttt{Enter}. Wynik po poprawieniu
metrum widzimy na~rysunku~\ref{fig:screenshot6}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot6.png}
    \caption{Menuet po poprawieniu tempa}
    \label{fig:screenshot6}
\end{figure}

Aktualny wynik zaczyna coraz bardziej przypominać oryginał. Kolejną rzeczą wartą poprawienia jest
skorygowanie drobnych błędów wykonawcy utworu.

W dziewiątym takcie, w obu rękach, widzimy nieoczekiwaną pauzę ósemkową. Mogła się tam znaleźć
zarówno przez zawahanie pianisty bądź też może być drobnym błędem wyznaczenia rozdzielczości
próbkowania utworu. Niezależnie jednak skąd co doprowadziło do takiego stanu rzeczy pauzę możemy
bez żadnego problemu wyeliminować. Edytor Lilypond jest okraszony komentarzami które pozwalają
łatwo zidentyfikować dziewiąty takt w obu rękach, jednak jako że są to jedyne występujące pauzy
w utworze, możemy się ich łatwo pozbyć wykorzystując wbudowany mechanizm
\emph{Search \& Replace}.
Zamieniając z jego pomocą wszystkie wystąpienia \texttt{r8} na ciąg znaków zerowej długości
otrzymujemy wynik widoczny na~rysunku~\ref{fig:screenshot7}.

Warto zauważyć, że po usunięciu nut (czy też pauz) z utworu nie zostaje po nich
puste miejsce, zamiast tego kolejne nuty i pauzy są przesuwane w lewo i zajmują miejsce tych
usuniętych.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot7.png}
    \caption{Menuet po usunięciu nadmiarowych pauz}
    \label{fig:screenshot7}
\end{figure}

Na tym etapie widzimy kilka błędnie określonych długości nut. W takcie dziesiątym oraz dwunastym
znajdują się dźwięki \begin{math} G \end{math}, które zamiast ćwierćnutami stały się ósemkami.
Po poprawieniu ich wartości na poprawne ukazuje się nam wynik widoczny
na~obrazku~\ref{fig:screenshot8}. Na dole tegoż obrazka widać również wyrażenie regularne
\texttt{g'8\textbackslash{}s+g'8}, które może posłużyć do szybkiej podmiany ósemek z taktu dwunastego na
żądane wartości (w tym przypadku \texttt{g'4 g'4}).

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{screenshot8.png}
    \caption{Menuet po poprawieniu długości dźwięków}
    \label{fig:screenshot8}
\end{figure}

Na tym etapie pozostaje nam jedynie poprawienie długości nut na samym końcu utworu: w lewej ręce
zamiast półnuty \texttt{g'2} powinniśmy byli mieć półnutę z kropką \texttt{g'2.}, zaś w ręce
prawej półnutę \texttt{g,2} zamiast aktualnie obecnej tam ćwierćnuty \texttt{g,4}. Przypadek jest
podobny do opisywanego na początku tego rozdziału braku pauz w piosence „Wlazł kotek na płotek”,
tutaj jednak mamy do czynienia z błędem ludzkim: pośpieszny wykonawca oderwał palce od klawiszy
nie „wytrzymując” kończącego utwór dwudźwięku przez całą jego długość. Po poprawieniu tego
drobnego niedopatrzenia otrzymujemy widoczny na~rysunku~\ref{fig:menuet_final} końcowy zapis
utworu, będący dokładnym odwzorowaniem zapisu z~rysunku~\ref{fig:menuet_orig}. Jedyną różnicą
jest inna nieco długość dźwięków z taktu ósmego, w tym jednak przypadku była ona celowym
zabiegiem wykonawcy i odzwierciedleniem jego wizji utworu, nie jest zatem traktowana jako błąd.

\begin{figure}[h!]
    \centering
    \begin{lilypond}
upper = {
    \key g \major
    \clef "treble"
    %{ measures 1 to 4 %}
d''4 g'8 a'8 b'8  c''8 | d''4 g'4 g'4 | e''4 c''8 d''8 e''8 fis''8 | 
%{ measures 4 to 7 %}
g''4 g'4 g'4 | c''4 d''8 c''8 b'8 a'8 | b'4  c''8 b'8 a'8 g'8 | fis'4 g'8 a'8  b'8 g'8 | 
%{ measures 8 to 11 %}
b'4 a'2 |     << d''4  >>  g'8 a'8 b'8 | c''8 d''4  g'4 g'4 | e''4 c''8 d''8 e''8 fis''8 | 
%{ measures 12 to 15 %}
g''4  g'4 g'4   c''4 | d''8 c''8 b'8  a'8 b'4 | c''8 b'8  a'8 g'8 a'4 | b'8 a'8 g'8 fis'8 g'2. | 
%{ measures 16 to 19 %}
}
lower = {
    \key g \major
    \clef "bass"
    %{ measures 1 to 4 %}
<< g2 d'2 b2 >>    a4 |  b2. |   c'2. | 
%{ measures 4 to 7 %}
    b2. |   a2. |      g2. |     d'4 b4   g4 | 
%{ measures 8 to 11 %}
 d'4 d8 c'8 b8 a8 | b2     a4 |   g4 b4 g4 | c'2. | 
%{ measures 12 to 15 %}
     b4 c'8 b8  a8 g8 | a2    fis4 |  g2   b4 |   c'4 d'4  d4 | 
%{ measures 16 to 19 %}
  g2 g,4
}
\score {
    \new PianoStaff <<
        \time 3/4
        \new Staff = "upper" \upper
        \new Staff = "lower" \lower
    >>
    \layout { }
}
    \end{lilypond}
    \caption{Finalna wersja utworu, po wszystkich poprawkach}
    \label{fig:menuet_final}
\end{figure}

Łatwo sobie wyobrazić, ile czasu zajęłoby zapisanie takiego utworu wpisując ręcznie każdą nutę
po kolei: a to przecież tylko krótki utwór. Wpisując go ręcznie na klawiaturze równocześnie
grając fragmentami na klawiaturze pianina zajęłoby mnóstwo czasu, i podczas takiego procesu
pomylilibyśmy się pewnie o wiele więcej razy, niż w powyższym przykładzie pomylił się program.
Błędy które wystąpiły mogliśmy również łatwo poprawić za pomocą narzędzi
dostarczonych przez program.

\newpage
\section{Podsumowanie}
\label{sec:podsumowanie}

Celem pracy było zaimplementowanie programu, który ułatwi pracę muzykom; programu który
możliwie jak największą część, a być może całość, mozolnej i podatnej na błędy pracy
polegającej na żmudnym przepisywaniu nut do komputera przeniesie na barki maszyny.
Przykład z poprzedniego rozdziału pokazuje, że cel ten został osiągnięty: program Lilith
jest w stanie wykonać niemal całą pracę za użytkownika, pozostawiając do poprawki jedynie
drobne potknięcia czy to algorytmu, czy też wykonawcy utworu. Otrzymaliśmy solidne, użyteczne
i łatwe w obsłudze narzędzie, oferujące dużo więcej niż komercyjne oprogramowanie dostępne
na rynku.

\newpage
\section{Bibliografia}
\label{sec:bibliografia}

\begin{enumerate}
\item Opis formatu Lilypond: \url{http://lilypond.org/doc/v2.18/Documentation/learning-big-page.html}
\item Opis formatu MIDI: \url{http://www.sonicspot.com/guide/midifiles.html}
\item Dokumentacja używanej biblioteki MIDI: \url{https://metacpan.org/pod/MIDI}
\item Franciszek Wesołowski -- „Zasady Muzyki” (ISBN: 83-224-0461-1)
\end{enumerate}

\end{document}
